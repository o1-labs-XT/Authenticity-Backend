# MinIO Implementation Plan for Authenticity Backend

## Problem Statement

The API and Worker services run in separate containers on Railway, preventing the worker from accessing temporary image files saved by the API. This causes all proof generation jobs to fail with "ENOENT: no such file or directory" errors.

## Solution: MinIO Object Storage

Deploy MinIO as a self-hosted S3-compatible object storage service on Railway to provide shared file storage between API and Worker services.

## Deployment Options

### Option 1: Railway One-Click Template (Recommended - 5 minutes)

1. **Deploy MinIO via Railway Template**
   - Navigate to: https://railway.com/deploy/minio
   - Click "Deploy on Railway"
   - Railway automatically provisions:
     - MinIO service with persistent volume
     - Auto-generated `MINIO_ROOT_USER` and `MINIO_ROOT_PASSWORD`
   - Add environment variable: `MINIO_BUCKET=authenticity-images`
   - Deploy the service

2. **Access Details**
   - Internal API endpoint: `http://minio.railway.internal:9000`
   - Public API endpoint: `https://[your-service].railway.app`
   - Web Console: `https://[your-service].railway.app:9001`
   - Credentials: Check Railway environment variables

### Option 2: Manual Service Addition

1. **Add MinIO service to existing Railway project**
2. **Configure with Docker image**: `minio/minio:latest`
3. **Set command**: `server /data --console-address ":9001"`
4. **Add persistent volume**: Mount at `/data`
5. **Configure environment variables** (see below)

## Environment Variables Configuration

### MinIO Service
```bash
MINIO_ROOT_USER=minioadmin  # Auto-generated by Railway
MINIO_ROOT_PASSWORD=<secure-password>  # Auto-generated by Railway
```

### API Service
```bash
MINIO_ENDPOINT=http://minio.railway.internal:9000
MINIO_ACCESS_KEY=<copy-from-minio-service>
MINIO_SECRET_KEY=<copy-from-minio-service>
MINIO_BUCKET=authenticity-images
MINIO_REGION=us-east-1  # Required but ignored by MinIO
```

### Worker Service
```bash
# Same as API Service
MINIO_ENDPOINT=http://minio.railway.internal:9000
MINIO_ACCESS_KEY=<copy-from-minio-service>
MINIO_SECRET_KEY=<copy-from-minio-service>
MINIO_BUCKET=authenticity-images
MINIO_REGION=us-east-1
```

## Implementation Steps

### Phase 1: Infrastructure Setup

1. **Deploy MinIO on Railway** (5 minutes)
   - Use Railway template or manual setup
   - Verify service is running via web console
   - Create bucket manually or via startup script

2. **Configure Environment Variables** (5 minutes)
   - Add MinIO credentials to API and Worker services
   - Use Railway's internal networking for security

### Phase 2: Code Implementation

#### Step 1: Install Dependencies
```bash
npm install @aws-sdk/client-s3
npm install --save-dev @types/node
```

#### Step 2: Create Storage Configuration
```typescript
// src/config/storage.config.ts
export interface StorageConfig {
  endpoint: string;
  region: string;
  accessKey: string;
  secretKey: string;
  bucket: string;
  forcePathStyle: boolean;
}

export const storageConfig: StorageConfig = {
  endpoint: process.env.MINIO_ENDPOINT || 'http://localhost:9000',
  region: process.env.MINIO_REGION || 'us-east-1',
  accessKey: process.env.MINIO_ACCESS_KEY || '',
  secretKey: process.env.MINIO_SECRET_KEY || '',
  bucket: process.env.MINIO_BUCKET || 'authenticity-images',
  forcePathStyle: true, // Required for MinIO
};
```

#### Step 3: Create MinIO Storage Service
```typescript
// src/services/storage/minio.service.ts
import {
  S3Client,
  PutObjectCommand,
  GetObjectCommand,
  DeleteObjectCommand,
  CreateBucketCommand,
  HeadBucketCommand
} from '@aws-sdk/client-s3';
import { storageConfig } from '../../config/storage.config.js';
import { logger } from '../../utils/logger.js';

export class MinioStorageService {
  private client: S3Client;
  private bucket: string;

  constructor() {
    this.bucket = storageConfig.bucket;
    this.client = new S3Client({
      endpoint: storageConfig.endpoint,
      region: storageConfig.region,
      credentials: {
        accessKeyId: storageConfig.accessKey,
        secretAccessKey: storageConfig.secretKey,
      },
      forcePathStyle: storageConfig.forcePathStyle,
    });
  }

  async ensureBucket(): Promise<void> {
    try {
      await this.client.send(new HeadBucketCommand({ Bucket: this.bucket }));
    } catch (error) {
      logger.info(`Creating bucket: ${this.bucket}`);
      await this.client.send(new CreateBucketCommand({ Bucket: this.bucket }));
    }
  }

  async uploadImage(key: string, buffer: Buffer, contentType: string = 'image/png'): Promise<void> {
    await this.client.send(new PutObjectCommand({
      Bucket: this.bucket,
      Key: key,
      Body: buffer,
      ContentType: contentType,
    }));
    logger.debug(`Uploaded image to MinIO: ${key}`);
  }

  async downloadImage(key: string): Promise<Buffer> {
    const response = await this.client.send(new GetObjectCommand({
      Bucket: this.bucket,
      Key: key,
    }));

    const chunks: Uint8Array[] = [];
    for await (const chunk of response.Body as any) {
      chunks.push(chunk);
    }
    return Buffer.concat(chunks);
  }

  async deleteImage(key: string): Promise<void> {
    await this.client.send(new DeleteObjectCommand({
      Bucket: this.bucket,
      Key: key,
    }));
    logger.debug(`Deleted image from MinIO: ${key}`);
  }

  generateStorageKey(sha256Hash: string): string {
    return `images/${sha256Hash}`;
  }
}
```

#### Step 4: Update Upload Handler
```typescript
// src/handlers/upload.handler.ts
// Add to constructor
constructor(
  private verificationService: ImageAuthenticityService,
  private repository: AuthenticityRepository,
  private jobQueue: JobQueueService,
  private storageService: MinioStorageService  // Add this
) {}

// In handleUpload method, after validation:
// Upload to MinIO
const storageKey = this.storageService.generateStorageKey(sha256Hash);
await this.storageService.uploadImage(storageKey, imageBuffer);

// Update job queue payload
await this.jobQueue.enqueueProofGeneration({
  sha256Hash,
  signature,
  publicKey,
  storageKey,  // Replace imagePath with storageKey
  tokenOwnerAddress,
  tokenOwnerPrivateKey: tokenOwnerPrivate,
  uploadedAt: new Date(),
  correlationId: (req as Request & { correlationId: string }).correlationId,
});

// Clean up temp file immediately
fs.unlinkSync(file!.path);
```

#### Step 5: Update Worker
```typescript
// src/workers/proofGenerationWorker.ts
// Add to constructor
constructor(
  private boss: PgBoss,
  private repository: AuthenticityRepository,
  private imageAuthenticityService: ImageAuthenticityService,
  private proofGenerationService: ProofGenerationService,
  private proofPublishingService: ProofPublishingService,
  private storageService: MinioStorageService  // Add this
) {}

// In job processing:
// Download from MinIO
const imageBuffer = await this.storageService.downloadImage(job.data.storageKey);

// Write to temporary file for processing
const tempPath = `/tmp/image-${Date.now()}-${job.data.sha256Hash}.png`;
await fs.writeFile(tempPath, imageBuffer);

try {
  // Process with temp file
  const { isValid, verificationInputs, error } =
    this.imageAuthenticityService.verifyAndPrepareImage(
      tempPath,
      signature,
      publicKey
    );

  // ... rest of processing ...

} finally {
  // Always clean up
  await fs.unlink(tempPath).catch(() => {});

  // Delete from MinIO after successful processing
  if (status === 'verified') {
    await this.storageService.deleteImage(job.data.storageKey);
  }
}
```

#### Step 6: Update Job Queue Types
```typescript
// src/services/queue/jobQueue.service.ts
export interface ProofGenerationJobData {
  sha256Hash: string;
  signature: string;
  publicKey: string;
  storageKey: string;  // Replace imagePath
  tokenOwnerAddress: string;
  tokenOwnerPrivateKey: string;
  uploadedAt: Date;
  correlationId: string;
}
```

### Phase 3: Deployment

#### Deployment Order (Zero Downtime)

1. **Deploy MinIO Service** (Day 1)
   - Deploy and verify MinIO is running
   - Create bucket via console or API

2. **Deploy API Changes** (Day 2)
   - Add backward compatibility:
   ```typescript
   // Support both old and new job formats
   const jobData = {
     ...existingData,
     storageKey: storageKey,
     imagePath: tempPath, // Keep for backward compatibility
   };
   ```
   - Monitor for errors

3. **Deploy Worker Changes** (Day 3)
   - Add fallback logic:
   ```typescript
   // Try MinIO first, fallback to file path
   let imageBuffer: Buffer;
   if (job.data.storageKey) {
     imageBuffer = await this.storageService.downloadImage(job.data.storageKey);
   } else if (job.data.imagePath) {
     imageBuffer = await fs.readFile(job.data.imagePath);
   }
   ```

4. **Cleanup** (Day 7)
   - Remove backward compatibility code
   - Remove imagePath from job data structure

## Monitoring & Maintenance

### Health Checks
```typescript
// Add to health check endpoint
async checkMinioHealth(): Promise<boolean> {
  try {
    await this.storageService.client.send(
      new HeadBucketCommand({ Bucket: this.bucket })
    );
    return true;
  } catch {
    return false;
  }
}
```

### Cleanup Job (Optional)
```typescript
// Run daily to clean orphaned images
async cleanupOrphanedImages(): Promise<void> {
  // List all objects older than 24 hours
  // Check if they have corresponding database records
  // Delete orphaned objects
}
```

### Monitoring Metrics
- Track upload/download latencies
- Monitor MinIO disk usage
- Alert on connection failures
- Track cleanup job success rate

## Rollback Plan

If issues arise:

1. **Quick Rollback**
   - Revert worker to previous version
   - API continues uploading to MinIO (no impact)
   - Fix issues and redeploy

2. **Full Rollback**
   - Stop MinIO uploads in API
   - Revert to filesystem approach
   - Investigate and fix issues

## Cost Considerations

### Railway Costs
- **MinIO Service**: ~$5-10/month (512MB RAM)
- **Storage Volume**: $0.25/GB/month
- **Network**: Internal traffic is free

### Storage Estimation
- Average image: 500KB
- 1000 images/day = 15GB/month
- Monthly storage cost: ~$3.75

## Security Considerations

1. **Use Internal Networking**
   - MinIO should only be accessible internally
   - API/Worker use `minio.railway.internal:9000`

2. **Access Control**
   - Use strong passwords for MinIO root user
   - Consider creating service-specific users with limited permissions

3. **Encryption**
   - Enable TLS for external connections
   - Consider encrypting objects at rest

## Success Criteria

- [ ] MinIO deployed and accessible
- [ ] API successfully uploads images to MinIO
- [ ] Worker successfully downloads and processes images
- [ ] Old filesystem-based jobs still process correctly
- [ ] Images are deleted after successful processing
- [ ] No increase in job failure rate

## Timeline

- **Day 1**: Deploy MinIO, configure environment
- **Day 2**: Deploy API changes with backward compatibility
- **Day 3**: Deploy Worker changes with fallback
- **Day 7**: Remove backward compatibility code
- **Day 14**: Add monitoring and cleanup jobs

## Next Steps

1. Deploy MinIO using Railway template
2. Configure environment variables
3. Implement storage service
4. Update API and Worker
5. Test in staging environment
6. Deploy to production with monitoring